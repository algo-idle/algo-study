# 1149번: RGB 거리 (실버 1)
|시간 제한|메모리 제한|
|:--:|:--:|
|0.5초|128MB|

## 문제
RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.

집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.

1번 집의 색은 2번 집의 색과 같지 않아야 한다.
N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.
## 문제 설명
제한시간이 0.5인걸 보고 2차원 배열을 효율적으로 탐색해야하는 문제임을 알았는데 아무리해도 답을 몰라서 찾아봤는데
럴수가 DP 문제였다. 미리 결과 테이블의 모습을 예측하고 3번동안 각 최소값으로 값을 변겨하면 마지막에 최소값이 모여있는 배열을 출력하면 되는 문제

한번 더 풀어볼 필요있음
## 입력
첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다. 집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.
```
3
26 40 83
49 60 57
13 89 99
```

## 출력
첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.
```
96
```
## 코드
```
N = int(input())
costs = [list(map(int, input().split())) for _ in range(N)]

dp = [[0] * 3 for _ in range(N)] #초기화 [0,0,0]으로 2차원 배열 초기화

dp[0][0] = costs[0][0]
dp[0][1] = costs[0][1]
dp[0][2] = costs[0][2]

for i in range(1, N):
    dp[i][0] = costs[i][0] + min(dp[i-1][1], dp[i-1][2])
    dp[i][1] = costs[i][1] + min(dp[i-1][0], dp[i-1][2])
    dp[i][2] = costs[i][2] + min(dp[i-1][0], dp[i-1][1])

result = min(dp[N-1][0], dp[N-1][1], dp[N-1][2])

print(result)

```

## 채점 결과
<img width="1157" alt="image" src="https://github.com/user-attachments/assets/67fcf2ff-08a9-42ac-8dc5-ef71b176d7c1">


## 스트릭 (또는 자신이 매일 문제를 풀었다는 증거)
